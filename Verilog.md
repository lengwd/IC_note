# Pcchris note

## 一、同步复位还是异步复位

> * **同步复位** ：只有在时钟的作用下，复位信号才会生效。
> * **异步复位** ：无论时钟如何，只要给复位信号，立即生效。

## 二、FIFO

### 1. 同步FIFO

#### 1.1结构组成

> RAM: 用于数据存储
>
> 写指针：指示写的位置
>
> 读指针：指示读的位置
>
> full empty

#### 1.2 逻辑判断

> 写逻辑：判断未满-写数据-指针前移； 满了就 阻止
>
> 读逻辑：判断未空-读数据-指针迁移；空了就 阻止
>
> 空/满：用扩展位控制

### 2.异步FIFO

#### 2.1结构组成

> RAM: 用于数据存储
>
> 写指针：指示写的位置
>
> 跨域写信号：
>
> 读指针：指示读的位置
>
> 跨域读指针
>
> full empty

#### 2.2逻辑

> 在同步的基础上加一个gray编码+跨域
>
> 注意 判断空满的时候要同码比较

## 三、时钟跨域基础方案

1.单比特数据跨时钟域传输常常只用打两拍即可。

2.当要传输的数据较多时，可以在不同的时钟域之间使用FIFO。

3.少量数据传输时，在不同的时钟域之间可以使用握手协议。

### DFF

![figure]()1

!

## 四、快时钟域>>>慢时钟域

### 方法一：展宽+打拍同步

> * 展宽倍数要大于等于时钟倍数，保证可靠采样。
> * 展宽倍数不能大于信号脉冲间隔，否则会把相邻的“1”合并。
> * 信号设计时要兼顾展宽和信号频率，避免展宽导致信息丢失。

> 1、展宽是为了让慢时钟也可以采集到该信号，展宽的倍数一般根据频率相差的倍数适当选择即可。
> 2、在展宽时，如果有效电平很宽，即使使得慢时钟能够采样到多次也没关系，因为后续在慢时钟域中进行的边沿检测就是为了最终使得该信号的有效电平只有一个慢时钟周期。
>
> 3、对 READ_SYNC 打 2 拍目的是消除亚稳态，打两拍之后的亚稳态概率已经非常非常小了，由于有电路噪声，所以寄存器会恢复到固定电平。我们画出如下的时序图。

> (1) 展宽：打拍 OR起来
>
> (2)打拍：大两拍，得到脉冲。

### 方法二：握手协议

#### transmit moudle

1.输入输出

> - 输入：clk_t, rst_n_t, data_in, vaild, ack_t, data_in_ack_t
> - 输出：req_t, data_out_t

2.模块设计

> - 第一步：通过vaild的信号的上升沿触发，避免同一个周期中多个信号传递
> - 第二步：ack信号 打两拍
> - 第三步：分先后 对于同一次交换过程中而言（1）valid 上升沿 传递信号 并且拉高req_t（2）收到ack信号 接受data_in 并且拉低req_t
> - 注意：但是在写逻辑的时候要把（2）写在（1）的前面，保证完成了一次handshake再进行第二次
> - 注意：同一个寄存器的所有逻辑要写在一个周期中

#### receive

1.输入输出

> - 输入：clk_r, rst_n, data_in_r, req_r
> - 输出：ack_r, data_out_ack_r

2.模块设计

> - 第一步：req_r 信号打两拍同步
> - 第二步：（1）如果收到req_rdd的信号，就拉高ack_r并且传入信号、传出应答信号；（2）（之后transmit收到data_in信号，req_t会拉低）如果req_rdd拉低， ack_r信号拉低

#### top

> 引用模块，定义wire将二者联系起来

## 五、异步处理的办法

### 1.亚稳态

> 如果建立时间和保持时间不满足要求，可能产生不正确的亚稳态
>
> 如果直接输出，振荡时间可能超过一个时间周期，进而采样的还是亚稳态 所以采用 打两拍来减少出错的概率

### 2.异步的情况

> 维度：比特数、快到慢or慢到快、信息的类型

### 3.单比特

#### 3.1慢到快

打两拍orqualifier

注意

（1）同时要注意，慢时钟域下的宽度至少是快时钟周期的1.5倍；也就是说要有明显周期差。

（2）**源时钟域不能有组合逻辑输出，一定是寄存器输出**

#### 3.2 快到慢

##### 3.2.1 展宽+打拍

##### 3.2.2 握手 （少量数据）

### 4.多 bit信号

#### 4.1多比特信号不能像单比特同步的原因

> 不能保证多比特信号的之间的时序关系
>
> 例如：
>
> en 和 load在clk1中一个周期内同时为1，但是存在抖动；clk2在采样的时候就可能把en 和clk分别采样到两个周期

#### 4.2 格雷码

##### 4.2.1 binary <-> gray

> binary->gray:
>
> 右移一位 和 本身异或
>
> g = (b>>1) ^ b

> gray->binary:
>
> 最高位相同，高位与gray码的下一位异或，一次进行

##### 4.2.2 格雷码同步 （规律变化的数据 如计数器）

将二进制转换成格雷码，就可以避免同时变动多个信号，即避免bit之间的时序关系。

### 4.3 DMUX(无规律缓变得控制信号或者少量信号)

类似与qualifer, 即先打两拍同步一个信号（如enable）,再通过同步后的enable， 控制另一个信号（如data）

> - 注意1：data要缓于enable，否则根本没用
>   * 假如tx_data在tx_sel还没同步到目标域时就发生了变化，那么目标域采样到的数据可能不是预期的， **出现数据采样错误** 。
> - 注意2：在enble稳定1的时候 data不能发生变化
>   * 当rx_sel（同步后的tx_sel）在目标域稳定时，采样tx_data，如果此时tx_data发生变化，采样到的数据就不确定，可能出现毛刺或亚稳态。

### 4.4 异步FIFO （大量数据的同步）

一个时钟控制写信号，一个时钟控制读信号，FIFO提供一个缓冲的区域。

#### 4.4.1 基础概念

> BPRAM: Biderectional Port RAM

## 六、低功耗设计（降低翻转频率）

参考资料：https://zhuanlan.zhihu.com/p/640735516

### 6.1 **目的**

> (1). 便携式设备的需求
>
> (2). 可靠性和性能的需求
>
> 功耗越高，热量越多，噪声越大，越影响器件正常工作，设备性能降低。
>
> (3). 成本
>
> 功耗越大，热量越高，后期封装增加散热设备等，增加成本。

### 6.2 功耗的类型

> CMOS功耗=静态功耗+动态功耗=静态功耗+（翻转功耗+短路功耗）
>
> ***静态功耗*** ：漏电流引起的功耗
>
> ***动态功耗*** ：负载电容充放电时引起的功耗，包括翻转功耗和短路功耗。其中翻转功耗是数字电路要完成功能计算必须消耗的功耗，称为有效功耗；短路功耗是由于CMOS在翻转过程中PMOS管和NMOS管同时导通时消耗的功耗，称为无效功耗。

> 系统级 体系结构级  寄存器传输级/逻辑门级 晶体管级

### 6.3 低功耗技术

#### 6.3.1 体系结构 (记忆方法：三门控、三电压、异步、缓存)

##### (1)时钟门控

> 时钟门控基础版：与非门+非门（tips: 没有直接的与门）
>
> 问题：en信号可能在clk为1的时候变化 带来毛刺

> 时钟门控广泛版：clk为0的锁存器+与非门+非门
>
> 解决了毛刺问题

> 时钟树与锁存器的位置关系：
>
> 时钟树概念：是芯片或电路板中分发时钟信号的网络结构。它的作用是将主时钟信号（如晶振输出）分配到芯片内部所有需要时钟的模块和单元
>
> 门控时钟单元应尽量摆放在时钟树附近 ，即如果放的比较远 buffer还是在反转 没有节能

###### 组合门控与时序门控

> 组合门控: 只门控当前寄存器，后续寄存器不门控

> 时序门控: 前后两级的寄存器都受门控约束，如：在数据流中使用时序门控，将输入数据的使能通过插入寄存器依次向后传递，达到门控后续寄存器的功能。（使能通过移位寄存器移动），这种结构可用于计算单元，触发加法器/乘法器等。时序门控时钟转换只在有多余16个触发器的情况下才更有效率[2]

##### （2）动态电压频率调节（DVFS)

> 把电压和频率降到刚刚满要求
>
> 注意：
>
> 先降频 在降压： 如果先降压 器件delay变大 频率高 出现时序违规
>
> 先升压 在升频： 如果先升频 delay还是不满足要求

##### （3）基于缓存

> 把频繁访问的数据放在缓存中，使得计算的消耗大大下降

##### （4）异步设计

> 没有工作的部分 不工作

##### （5）电源门控

> 细粒度： 在逻辑块 上方（pmos）or 下方 （nmos）来控制开关， 注意不能有太大的下降电阻，所以nmos 面积更小， 高阈值可以减少漏电流

> 粗粒度：一个电源开关网络，注意IR drop, 以及隔离单元

> **IR drop**指的是电源网络中，由于电流流经金属线或晶体管产生的电阻，导致电源电压在芯片内部某些区域出现下降。

##### （6）多阈值电压

基础：

> 高阈值：漏电小，速度慢
>
> 低阈值：漏电打，速度快

设计方法：

> 关键路径：低阈值
>
> 其他路径：高阈值

思路：

> 时序要求前提，先采用低阈值综合，在采用高阈值替代时间裕度大的路径
>
> 功耗要求前提，高阈值，低阈值替代关键路径。

##### (7) 多（外部）电压

> 电压低、I变小、翻转频率变小

> 注意不同模块之间需要电压隔离或者电平转换单元

##### （8）存储器电源门控

> sram 占功耗 1/3 其他事时钟树和逻辑

> - 不用的时候关闭, 分成多个模块, 只打开用的一部分
> - 基底偏执,减少漏电流
> - 多模式,读写时高电压, 其他模式低电压
> - 直接连接再裸片 堆叠封装 减少电容

#### 6.3.2 寄存器级传输级

##### （1）状态机编码和解码

###### a. gray码

> 每次都只变化一次码

###### b. 经常跳转的状态机 可以设计

> 50% 状态机 都是 state1->state2
>
> 1010->0101 原来是四翻转
>
> 0101->0100 现在是一反转

###### c.分解状态机

> 将高使用的状态和低使用频率的状态机分开 并且 分为高低两个或者多个小状态机的类

###### d.小状态机可以用one-hot编码

##### （2）独热编码路由器

> 将二进制编码转换为独热编码，比如说翻

##### （3）操作数隔离

> 总线数据常常会发生没有意义的转换，如果没有采样，则没有含义
>
> 有是能信号的时候 把前面的逻辑也加上使能信号
>
> - 逻辑传递
> - 数据传递

##### （4）共享逻辑

> 设计的时候 多使用共享逻辑 减少面积和功耗

> case(a)
>
> 1'b1: out1 = (v1 > v2)
>
> 1'b0: out2 = ~(v1 > v2)
>
> endcase

> assign  campare = (v1 > v2)
>
> case(a)
>
> 1'b1: out1 = campare
>
> 1'b0: out2 = ~campare
>
> endcase

##### (5) 总线翻转

> 如果汉明距离大于总线宽度N的一半
>
> 加上反码和解码

##### （6）高活跃度网络放在深处

##### （7）电平信号变成脉冲信号

#### 6.3.3 门级低功耗

##### （1）毛刺级消除

##### （2）逻辑级优化

###### 门的大小

> 非关键路径，小门，电容小
>
> 负载大的门，增大，减少翻转时间，漏电流

###### 门的配重

> 翻转频率高的门采用小电容

###### 逻辑排序

> 翻转频率高的引脚驱动门少

###### 重新映射

> 多级门用一个门代替

##### （3）物理级

> 低功耗库、低功耗设计、功耗优化设计、减少毛刺、减小电容

#### 6.3.4 工艺级

##### （1）body bias

> 工作状态bias =0 , 休眠状态反偏

##### （2）减少氧化层厚度

> 效果好，但是有隧穿效应，需要h-k材料

##### （3）减少电容

## 七、 有符号数

### 7.1 移动

> - 左移：符号数不变，高位丢掉，低位补零
> - 右移：符号数不变，高位补不符号数， 低位丢掉

### 7.2 移位数超过位宽

> - 左移：取模
> - 右移：全部符号数
> - 原因：硬件优化

### 7.3 原码、反码、补码

> 针对有符号数
>
> - 正数三者相同
> - 负数：反码 = 原码 （符号数不变 其余位取反），补码=反码+1
>
> 不同进制下的原、反、补其实就是二进制转换为不同进制罢了

## 八、latch

> - 上学时，老师说判断语句要把条件写全，不然会生成锁存器
> - 做项目时又说多比特寄存器信号的赋值一定要加if条件，不让出现else的赋值。

> SR锁存器： 00，保持；10， 0； 01，1；11，翻转；

> 生成：组合逻辑中条件没写全

> 缺点：
>
> - 时序分析复杂：一般只分析时钟沿，但是锁存器在enable沿变化
> - FPGA中：锁存器需要 2个LUT+1个Flip-flop
> - 容易出现毛刺

## 九、状态机

参考资料：https://zhuanlan.zhihu.com/p/72462872

### 9.1 状态机写法-三段式

> - 状态跳转逻辑 （always@(*) case）
> - 状态触发 (state<=next_state)
> - 输出逻辑

### 9.2 case中 default的重要性

> - 时序电路：额外的寄存器来保证不变
> - 组合逻辑：生成latch

### 9.3 mearly 和 moore

> - mearly: next = f(state, in) out= f(state, in), 少一个状态， 但是会受毛刺的影响
> - moore: next = f(state, in) out = f(state)反之

### 9.4 编码

#### 9.4.1 二进制

> 产生毛刺， 翻转多，功耗高, 门数log2(N)

#### 9.4.2 格雷码

> 每次只翻转一个功耗少门数log2(N)

#### 9.4.3 独热码

> 每次翻转两个寄存器， 但是逻辑简单，速度快，易于修改
>
> 缺点：FF多 逻辑输出毛刺； 容易异步亚稳态概率大

## 十、STA 检查常见麻烦情况总结

### 1. **异步输入信号**

- 外部输入和主时钟不同步，容易导致亚稳态和不可预测的时序问题。
- 解决方法：使用多级同步器。

### 2. **时钟域跨越（Clock Domain Crossing, CDC）**

- 信号从一个时钟域传到另一个时钟域，容易漏检或误检时序问题。
- 解决方法：专用 CDC 检查工具、多级同步器。

### 3. **多时钟设计**

- 芯片内有多个时钟源，时钟频率、相位不同，容易导致时序分析复杂。
- 解决方法：时钟约束清晰、时钟分组管理。

### 4. **时钟不确定性（Jitter/Skew）**

- 时钟抖动、偏斜影响采样时刻，导致时序裕度降低。
- 解决方法：合理设置时钟不确定性参数。

### 5. **门控时钟（Clock Gating）**

- 时钟信号被门控逻辑控制，可能导致时钟树延迟变化，STA难以准确分析。
- 解决方法：门控逻辑时序约束、特殊时钟树分析。

### 6. **异步复位/使能信号**

- 复位、使能信号与时钟无关，容易导致时序分析遗漏。
- 解决方法：用同步复位/使能，或特殊约束处理。

### 7. **黑盒/未知模块**

- IP核或第三方模块未提供详细时序模型，STA无法准确分析其时序。
- 解决方法：补充时序模型或用边界约束。

### 8. **复杂的时序路径（多级组合逻辑、长路径）**

- 路径过长或组合逻辑级数过多，容易出现时序违例。
- 解决方法：路径分割、插入寄存器。

---

#### 记忆口诀

> **“异时跨域多时钟，门控复位黑盒多，复杂路径需关注。”**
> （异步、跨域、多时钟、门控、复位、黑盒、复杂路径）

## 十一、AMBA总线协议

相关连接：【带你搭建自己的AMBA系统】https://www.zhihu.com/column/c_1663245806869291008

### 11.1 APB (Adavanced Peripheral Bus)

#### 11.1 APB2

信号都以P开头表示是APB协议的类别, 两个时钟周期

> 时钟信号：
>
> PCLK PRESETn (这两个不用介绍)
>
> 控制信号：
> PSEL： 拉高表示要进行一次通信
>
> PADDR：通信的地址表示要和哪个外设连接
>
> PENABEL：APB的设计， 在第一个PSEL拉高之后表示 PENABEL信号表示数据可以传输
>
> 读写信号：
>
> PWRITE: 拉高为写 拉低为为读
>
> PRDATA：读信号线
>
> PWDATA：写信号线

> 关于PENABLE的设计, 属于历史遗留问题, 早期的制造工艺为无法以可周期内的数据传输
>
> - 如果slave也是CLK1控制,其实可以不用PENABLE
> - 如果slave只是组合逻辑,是需要PENABLE的

#### 11.2 APB3

相比新增两个信号， PREADY PSLVERR

> PREADY: 表示slave准备好了，可以发起通信， 这里出现了一个新名词 “反压”， 即 slave可以反过来控制master, 这是为了处理 slave中可能还没有处理好信号等情况, 如果有等待状态,可能需要超过两个时钟周期来完成传播
>
> PSLVERR: 即PBA slave error, 表示slave 错误,这次传输无效(比如无效地址 超时未响应等) 用于避免总线锁死

#### 11.3 APB4

新增两个信号 PPORT PSTRB

> PPORT: 控制访问属性 3bit 分别控制特权\安全\数据or指令
>
> PSTRB:(PBA strobe) 表示稀疏写, 4bit 如果 4'b1000 则表述只写入最高位

### 11.2 AHB-Lite (Advanced High-performance Bus)

#### 11.2.0 术语补充

> 1KB边界对齐就是：每个Slave的基地址必须是1024字节的整数倍（低10位全0）。

#### 11.2.1 信号

AHB中的信号 以H开头

AHB信号 多个master 和 多个 slave 之间信息的传输

AHB-Lite 是简化版 单个master和多个slave之间的传输

（1）全局信号

> HCLK
>
> HRESETn

（2）master 信号

> 控制信号 :
>
> HADDR
>
> HWRITE
>
> 数据信号：
>
> HWDATA
>
> 数据描述信号：
>
> HBURST 突发传输 （还不懂）
>
> HMASTERLOCK (原子操作)
>
> HPORT: 信号类型 保护控制信号
>
> HTRANS: 传输类型（懂）
>
> HSIZE：信号大小

（3）slave

> HRDATA
>
> HREADYOUT
>
> HPESP: 高为正常， 低为不正常

（4）decoder

> HSELx

（5）MUX

> HDATA
>
> HREADYOUT
>
> HRESP

#### 11.2.2 AHB-Lite 控制信号

> 连接:https://zhuanlan.zhihu.com/p/630647524

(1) 传输类别

> IDEL
>
> BUSY
>
> NONSEQ
>
> SEQ

(2) locked transfer

和（4）一样是一种操作，通过MASTERLOCKED信号，来避免多个master访问一个slave带来的时序错误

(3)tranfer size

从 000 为 8bit 开始递增 每增加1 乘2 例如 010 是32bit

(4)burst operation

是一种把多笔transfer打包为整体的操作

SINGLE: 1笔 可以是IDEL NONSEQ

INCR: 非定常 不可以跨越1kb边界

INCRx: x 是 4 8 16 不可以跨越1kb边界

WRAPx: cache line 4 8 16笔transfer

> 补充1：跨域边界指的是 一个地址的不能超过1k范围 这样会超过一个slave到另一个slave
>
> 补充2：cache line（缓存行）是缓存（Cache）中数据存储和传输的基本单位。 “一大块数据”就叫cache line，常见长度有32字节、64字节等。
>
> 补充3：什么是 critical word first（关键字优先）
>
> 当CPU访问某个地址（比如0x1008），发现Cache里没有，就要从内存取一整行（比如0x1000~0x103F）。
>
> 但CPU最着急用的是0x1008这个“关键字”（critical word），如果等全行都读完才给CPU，会慢。
>
> critical word first就是先把CPU需要的那一部分（0x1008~0x100B）优先传给CPU，剩下的再慢慢传。

能用BURST就用BURST

> 突发传输：一次命令，连续读一大块，效率高，延迟低。
>
> 单次传输：多次命令，分开读，效率低，延迟高。
>
> 突发传输像是你告诉快递员：“请把我家门口的8个包裹一起搬到我家里。”快递员一次性搬完，很快。
>
> 单次传输像是你每次只让快递员搬一个包裹，搬完一个再通知他下一个，他每次都要重新跑一趟，效率很低。

#### 11.2.3 AHB-Lite slave信号

> 链接：https://zhuanlan.zhihu.com/p/631208951

(1) HREADY 与 HRESP

这两个信号代表组成四个状态

> 10: 成功传输
>
> 00: slave 反压主机 等待slave处理信号
>
> 10：出错了 处理错误中
>
> 11：出错了 错误处理完成

错误处理操作：

> slave发现要出错了，加入一个00（等待）
>
> 然后分别加入以一个10和11来表示错误处理

（2）HPORT 保护信号

HPORT[0]: 取数据还是取指令

HPORT[1]：特权\非特权

HPORT[2]：bufferable

HPORT[3]：cacheable

> 补充：
> 对于写具有严格的先后顺序之分的地址空间，一般是Non-cacheable和Non-bufferable，否则可能会乱序。

#### 11.2.4 AHB局限性

> 链接: https://zhuanlan.zhihu.com/p/641564919

(1) 时代局限

> AHB协议本身是ARM公司在AMBA2这一代推出的协议，距今已经有20多年了，该协议本身存在着很多历史局限性，用今天的视角来看，AHB属于高不成低不就的一代协议。在低频低性能要求的情况下，论功耗面积等开销比不过APB协议。在高频高性能要求下，能跑到的主频和带宽又比不过AXI。

(2) 利用效率受限

> 虽然AHB有WDATA（写数据）和RDATA（读数据）信号，但控制信号只有一条路径。
>
>
>
> 而且每次传输都要遵守“命令和数据之间必须有一个时钟周期的延迟”（1T delay），
>
>
>
> 这就导致WDATA和RDATA无法同时工作，数据通道的利用率最多只有50%。
>
>
>
> 可以把它理解成半双工，而不是全双工。
>
> 全双工：比如电话，两边可以同时说话，利用率接近100%。
>
> 半双工（类似AHB）：像对讲机，一次只能一边说话，另一边等着，利用率只有50%。

(3) AXI 与 AHB

> AHB的低效——单车道+红绿灯
>
> 先有一辆车要读数据（读请求），读数据要等很久（比如100秒），这期间后面的写请求车都要等着，不能走。
>
> 如果读写频繁切换，效率就特别低。

> AXI的高效——双车道+无等待
>
> 读写通道分离：就像有两条独立的车道，一条专门给读请求车走，另一条给写请求车走，两边互不影响。（全双工）
>
> Outstanding机制：允许很多车在路上同时行驶，不用等前面一辆车到终点，后面的车才能出发。



### 11.3 AHB 和 APB转接桥

#### 11.3.1 转接桥前言

> 链接: https://zhuanlan.zhihu.com/p/631956271

(1) HREADYOUT 与 HREADYIN的区分

HREADYOUT是slave发出的信号 由slave控制

HREADYIN是MUX的发出(可能用传出准确点? 不过无所谓)的信号,有两个作用:

> - 发给master告诉其还没完成传输 不要继续发送新的信号
> - 发给其他slave 告诉还有信号没有完成 其不要接受信号

错误举例:

对于 slave S1 S2 而言:

> - 如果master保持控制s1, master 看到 s1 保持, 但是s2 来着不拒, 就会收到重复的信号,甚至错误的地址
> - 如果master看到s2, 就不会保持, 进而数据错误

(2) memory mapping

在边界地址不能覆盖的放, 放上default slave

#### 11.3.2 AHB2APB同步桥设计

> 链接:https://zhuanlan.zhihu.com/p/638541895
>
> 暂时没仔细看 这次学习主要以了解各种协议为主

### 11.3 AXI协议 (Advanced eXtensible Interface)

#### 11.3.1 AXI协议导论

> 链接: https://zhuanlan.zhihu.com/p/641597910

细节记录:

> - Master的VALID是不允许中途拉低的，这是协议硬性规定的，一旦拉高，就必须等待握手成功才允许拉低。
> - 此外VALID是不可以依赖于READY的，不能说READY拉高VALID再拉高，体现在具体的设计中实际上是不能允许将READY作为逻辑输入，生成VALID信号。要不然有可能造成死锁的状况

(1) 不同数据通道间的先后顺序

> 读
>
> - 读地址 握手信号之间没有要求
> - 读信号 握手信号之间没有要求 但是信号要在读地址之后

> 写
>
> - 写地址 握手信号之间没有要求
> - 写信号 握手信号之间没有要求 也不需要在写地址之后 没有先后关系
> - 返回信号 要在写地址 和写信号之后
